Johanes Sunarto
James Patrick Stallkamp
Andriy Y Solovyov


Final Project Part 1


1) Explain testIsValid Function of UrlValidator test code.
        The testIsValid function generates urls by creating all the combinations of the permutations of a urls, scheme, authority, port, path, and query. If all the pieces are valid then the url is valid. 


* /*********** UrlValidator object is first built. Then, two known urls are tested to make sure UrlValidator is running correctly. **************/
* public void testIsValid(Object[] testObjects, long options) {
*       UrlValidator urlVal = new UrlValidator(null, null, options);
*       assertTrue(urlVal.isValid("http://www.google.com")); //Testing two known urls to make sure 
*       assertTrue(urlVal.isValid("http://www.google.com/")); // this is running correctly
*       int statusPerLine = 60;
*       int printed = 0;
*       if (printIndex)  {
*          statusPerLine = 6;
*       }
*       do {
*          StringBuffer testBuffer = new StringBuffer();        // Create a string buffer object.
*          boolean expected = true;
* * /*********** The for loop here iterates through the different pieces of a url to generate all the possible combinations of the permutations of the pieces of a url. Url is concatenated as testBuffer **************/
* *          for (int testPartsIndexIndex = 0; testPartsIndexIndex < testPartsIndex.length; ++testPartsIndexIndex) {
*             int index = testPartsIndex[testPartsIndexIndex];
*             ResultPair[] part = (ResultPair[]) testObjects[testPartsIndexIndex];
*             testBuffer.append(part[index].item);
*             expected &= part[index].valid;
*          }
* /***** Here the urls are checked to see if each piece that was used in the combination is valid, if all the pieces are valid then the url is valid. Validity is also checked vs expected. If Url is valid, print out the concatenated string from testBuffer*******/
*          //System.out.println(testPartsIndex[0]);
*          String url = testBuffer.toString();
*          boolean result = urlVal.isValid(url); 
*          
*          if(result == true)
*                  System.out.println(url);
*          assertEquals(url, expected, result);
*          
*          if (printStatus) {
*             if (printIndex) {
*                //System.out.print(testPartsIndextoString());
*             } else {
*                if (result == expected) {
*                   System.out.print('.');
*                } else {
*                   System.out.print('X');
*                }
*             }
*             printed++;
*             if (printed == statusPerLine) {
*                System.out.println();
*                printed = 0;
*             }
*          }
*       } while (incrementTestPartsIndex(testPartsIndex, testObjects)); //iterating through all parts of a url
*       if (printStatus) {
*          System.out.println();
*       }
*    }
* 2)  Give how many total number of urls it is testing
* Since a complete URL is composed of a scheme, authority, port, path, and query ( with 9, 19, 7, 10, and 15 possibilities, respectively), there are 9*19*7*10*3 = 35910 url possibilities. Hence, 35910 urls being tested.
3) Explain how it is building all the urls
* The urls are being generated by running through all possible permutations of the combinations of the url’s scheme, authority, port, path, and query. Each part is stored in arrays called ResultPair, which has two parts: a string representing a portion of a url and a boolean indicating whether or not it is valid. If all the Result Pairs that are used in a url are considered valid then the url is considered valid. 
4)  Give an example of valid url being tested and an invalid url being tested by testIsValid() method.
* An example of a valid url that was tested: http://go.com:80/test1
* An example of a non-valid url that was tested: 3ht://go.a1a:-1/../?action=view
5)  Do you think that a real world test (URL Validator's testIsValid() test in this case) is very different than the unit tests and card tests that we wrote (in terms of concepts & complexity)?
* The real world version of a software test in this case does not seem very different conceptually from the unit and card tests we employed. The concept was similar since essentially testIsValid() compares an test value against an expected result. The way they achieved this was also not too far fetched from our unit test; they simply applied a combinatorial method of generating semi-random urls. What is very different was the length of the test employed here. Whereas our unit and card tests for the toy dominion program was, in most cases, less than 100 lines, this test was much longer.